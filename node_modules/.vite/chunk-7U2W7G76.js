import {
  Layer_default,
  Layer_default3 as Layer_default2,
  VectorRenderTile_default,
  VectorTile_default,
  ViewHint_default
} from "./chunk-JCMTTSRR.js";
import {
  ENABLE_RASTER_REPROJECTION,
  TileImage_default,
  UrlTile_default,
  createForProjection,
  createFromTemplates,
  createXYZ,
  extentFromProjection
} from "./chunk-LVUWURYR.js";
import {
  TileCache_default,
  TileRange_default,
  TileState_default,
  fromKey,
  getCacheKeyForTileKey,
  getKeyZXY
} from "./chunk-FWZ4IL35.js";
import {
  loadFeaturesXhr
} from "./chunk-KMRUCRWH.js";
import {
  State_default
} from "./chunk-I5XJRMCO.js";
import {
  apply,
  compose,
  makeInverse,
  toString
} from "./chunk-LT7QKDD7.js";
import {
  fromUserExtent,
  get,
  getTransformFromProjections
} from "./chunk-ISLN5VAW.js";
import {
  cssOpacity
} from "./chunk-DZUBOF3Z.js";
import {
  toSize
} from "./chunk-KQA7WSDH.js";
import {
  EventType_default,
  numberSafeCompareFunction
} from "./chunk-QKN2LTGH.js";
import {
  applyTransform,
  assert,
  assign,
  buffer,
  containsExtent,
  createEmpty,
  equals,
  getIntersection,
  getTopLeft,
  getUid,
  intersects,
  isEmpty,
  isEmpty2
} from "./chunk-KSL5UQJJ.js";

// node_modules/ol/layer/BaseImage.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BaseImageLayer = function(_super) {
  __extends(BaseImageLayer2, _super);
  function BaseImageLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    return _this;
  }
  return BaseImageLayer2;
}(Layer_default);
var BaseImage_default = BaseImageLayer;

// node_modules/ol/renderer/canvas/ImageLayer.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasImageLayerRenderer = function(_super) {
  __extends2(CanvasImageLayerRenderer2, _super);
  function CanvasImageLayerRenderer2(imageLayer) {
    var _this = _super.call(this, imageLayer) || this;
    _this.image_ = null;
    return _this;
  }
  CanvasImageLayerRenderer2.prototype.getImage = function() {
    return !this.image_ ? null : this.image_.getImage();
  };
  CanvasImageLayerRenderer2.prototype.prepareFrame = function(frameState) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var imageSource = this.getLayer().getSource();
    var hints = frameState.viewHints;
    var renderedExtent = frameState.extent;
    if (layerState.extent !== void 0) {
      renderedExtent = getIntersection(renderedExtent, fromUserExtent(layerState.extent, viewState.projection));
    }
    if (!hints[ViewHint_default.ANIMATING] && !hints[ViewHint_default.INTERACTING] && !isEmpty2(renderedExtent)) {
      if (imageSource) {
        var projection = viewState.projection;
        if (!ENABLE_RASTER_REPROJECTION) {
          var sourceProjection = imageSource.getProjection();
          if (sourceProjection) {
            projection = sourceProjection;
          }
        }
        var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
        if (image && this.loadImage(image)) {
          this.image_ = image;
        }
      } else {
        this.image_ = null;
      }
    }
    return !!this.image_;
  };
  CanvasImageLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;
    var size = frameState.size;
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var rotation = viewState.rotation;
    if (rotation) {
      var size_1 = Math.round(Math.sqrt(width * width + height * height));
      width = size_1;
      height = size_1;
    }
    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    var clipped = false;
    var render = true;
    if (layerState.extent) {
      var layerExtent = fromUserExtent(layerState.extent, viewState.projection);
      render = intersects(layerExtent, frameState.extent);
      clipped = render && !containsExtent(layerExtent, frameState.extent);
      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }
    var img = image.getImage();
    var transform = compose(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    var dw = img.width * transform[0];
    var dh = img.height * transform[3];
    assign(context, this.getLayer().getSource().getContextOptions());
    this.preRender(context, frameState);
    if (render && dw >= 0.5 && dh >= 0.5) {
      var dx = transform[4];
      var dy = transform[5];
      var opacity = layerState.opacity;
      var previousAlpha = void 0;
      if (opacity !== 1) {
        previousAlpha = context.globalAlpha;
        context.globalAlpha = opacity;
      }
      context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
      if (opacity !== 1) {
        context.globalAlpha = previousAlpha;
      }
    }
    this.postRender(context, frameState);
    if (clipped) {
      context.restore();
    }
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  };
  return CanvasImageLayerRenderer2;
}(Layer_default2);
var ImageLayer_default = CanvasImageLayerRenderer;

// node_modules/ol/layer/Image.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageLayer = function(_super) {
  __extends3(ImageLayer2, _super);
  function ImageLayer2(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  ImageLayer2.prototype.createRenderer = function() {
    return new ImageLayer_default(this);
  };
  return ImageLayer2;
}(BaseImage_default);
var Image_default = ImageLayer;

// node_modules/ol/source/VectorTile.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorTile = function(_super) {
  __extends4(VectorTile2, _super);
  function VectorTile2(options) {
    var _this = this;
    var projection = options.projection || "EPSG:3857";
    var extent = options.extent || extentFromProjection(projection);
    var tileGrid = options.tileGrid || createXYZ({
      extent,
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 22,
      minZoom: options.minZoom,
      tileSize: options.tileSize || 512
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      opaque: false,
      projection,
      state: options.state,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX === void 0 ? true : options.wrapX,
      transition: options.transition,
      zDirection: options.zDirection === void 0 ? 1 : options.zDirection
    }) || this;
    _this.format_ = options.format ? options.format : null;
    _this.sourceTileCache = new TileCache_default(_this.tileCache.highWaterMark);
    _this.overlaps_ = options.overlaps == void 0 ? true : options.overlaps;
    _this.tileClass = options.tileClass ? options.tileClass : VectorTile_default;
    _this.tileGrids_ = {};
    return _this;
  }
  VectorTile2.prototype.getFeaturesInExtent = function(extent) {
    var features = [];
    var tileCache = this.tileCache;
    if (tileCache.getCount() === 0) {
      return features;
    }
    var z = fromKey(tileCache.peekFirstKey())[0];
    var tileGrid = this.tileGrid;
    tileCache.forEach(function(tile) {
      if (tile.tileCoord[0] !== z || tile.getState() !== TileState_default.LOADED) {
        return;
      }
      var sourceTiles = tile.getSourceTiles();
      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
        var sourceTile = sourceTiles[i];
        var tileCoord = sourceTile.tileCoord;
        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {
          var tileFeatures = sourceTile.getFeatures();
          if (tileFeatures) {
            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {
              var candidate = tileFeatures[j];
              var geometry = candidate.getGeometry();
              if (intersects(extent, geometry.getExtent())) {
                features.push(candidate);
              }
            }
          }
        }
      }
    });
    return features;
  };
  VectorTile2.prototype.getOverlaps = function() {
    return this.overlaps_;
  };
  VectorTile2.prototype.clear = function() {
    this.tileCache.clear();
    this.sourceTileCache.clear();
  };
  VectorTile2.prototype.expireCache = function(projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);
    var usedSourceTiles = Object.keys(usedTiles).reduce(function(acc, key) {
      var cacheKey = getCacheKeyForTileKey(key);
      if (tileCache.containsKey(cacheKey)) {
        var sourceTiles = tileCache.get(cacheKey).sourceTiles;
        for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
          acc[sourceTiles[i].getKey()] = true;
        }
      }
      return acc;
    }, {});
    _super.prototype.expireCache.call(this, projection, usedTiles);
    this.sourceTileCache.expireCache(usedSourceTiles);
  };
  VectorTile2.prototype.getSourceTiles = function(pixelRatio, projection, tile) {
    var _this = this;
    if (tile.getState() === TileState_default.IDLE) {
      tile.setState(TileState_default.LOADING);
      var urlTileCoord = tile.wrappedTileCoord;
      var tileGrid = this.getTileGridForProjection(projection);
      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      var z = urlTileCoord[0];
      var resolution = tileGrid.getResolution(z);
      buffer(extent, -resolution, extent);
      var sourceTileGrid_1 = this.tileGrid;
      var sourceExtent = sourceTileGrid_1.getExtent();
      if (sourceExtent) {
        getIntersection(extent, sourceExtent, extent);
      }
      var sourceZ = sourceTileGrid_1.getZForResolution(resolution, 1);
      sourceTileGrid_1.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {
        var tileUrl = _this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
        var sourceTile = _this.sourceTileCache.containsKey(tileUrl) ? _this.sourceTileCache.get(tileUrl) : new _this.tileClass(sourceTileCoord, tileUrl ? TileState_default.IDLE : TileState_default.EMPTY, tileUrl, _this.format_, _this.tileLoadFunction);
        tile.sourceTiles.push(sourceTile);
        var sourceTileState = sourceTile.getState();
        if (sourceTileState < TileState_default.LOADED) {
          var listenChange_1 = function(event) {
            _this.handleTileChange(event);
            var state = sourceTile.getState();
            if (state === TileState_default.LOADED || state === TileState_default.ERROR) {
              var sourceTileKey = sourceTile.getKey();
              if (sourceTileKey in tile.errorTileKeys) {
                if (sourceTile.getState() === TileState_default.LOADED) {
                  delete tile.errorTileKeys[sourceTileKey];
                }
              } else {
                tile.loadingSourceTiles--;
              }
              if (state === TileState_default.ERROR) {
                tile.errorTileKeys[sourceTileKey] = true;
              } else {
                sourceTile.removeEventListener(EventType_default.CHANGE, listenChange_1);
              }
              if (tile.loadingSourceTiles === 0) {
                tile.setState(isEmpty(tile.errorTileKeys) ? TileState_default.LOADED : TileState_default.ERROR);
              }
            }
          };
          sourceTile.addEventListener(EventType_default.CHANGE, listenChange_1);
          tile.loadingSourceTiles++;
        }
        if (sourceTileState === TileState_default.IDLE) {
          sourceTile.extent = sourceTileGrid_1.getTileCoordExtent(sourceTileCoord);
          sourceTile.projection = projection;
          sourceTile.resolution = sourceTileGrid_1.getResolution(sourceTileCoord[0]);
          _this.sourceTileCache.set(tileUrl, sourceTile);
          sourceTile.load();
        }
      });
      if (!tile.loadingSourceTiles) {
        tile.setState(tile.sourceTiles.some(function(sourceTile) {
          return sourceTile.getState() === TileState_default.ERROR;
        }) ? TileState_default.ERROR : TileState_default.LOADED);
      }
    }
    return tile.sourceTiles;
  };
  VectorTile2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
    var coordKey = getKeyZXY(z, x, y);
    var key = this.getKey();
    var tile;
    if (this.tileCache.containsKey(coordKey)) {
      tile = this.tileCache.get(coordKey);
      if (tile.key === key) {
        return tile;
      }
    }
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var sourceExtent = this.getTileGrid().getExtent();
    var tileGrid = this.getTileGridForProjection(projection);
    if (urlTileCoord && sourceExtent) {
      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);
      buffer(tileExtent, -tileGrid.getResolution(z), tileExtent);
      if (!intersects(sourceExtent, tileExtent)) {
        urlTileCoord = null;
      }
    }
    var empty = true;
    if (urlTileCoord !== null) {
      var sourceTileGrid = this.tileGrid;
      var resolution = tileGrid.getResolution(z);
      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);
      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      buffer(extent, -resolution, extent);
      sourceTileGrid.forEachTileCoord(extent, sourceZ, function(sourceTileCoord) {
        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
      }.bind(this));
    }
    var newTile = new VectorRenderTile_default(tileCoord, empty ? TileState_default.EMPTY : TileState_default.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
    newTile.key = key;
    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      this.tileCache.replace(coordKey, newTile);
    } else {
      this.tileCache.set(coordKey, newTile);
    }
    return newTile;
  };
  VectorTile2.prototype.getTileGridForProjection = function(projection) {
    var code = projection.getCode();
    var tileGrid = this.tileGrids_[code];
    if (!tileGrid) {
      var sourceTileGrid = this.tileGrid;
      tileGrid = createForProjection(projection, void 0, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : void 0);
      this.tileGrids_[code] = tileGrid;
    }
    return tileGrid;
  };
  VectorTile2.prototype.getTilePixelRatio = function(pixelRatio) {
    return pixelRatio;
  };
  VectorTile2.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    return [
      Math.round(tileSize[0] * pixelRatio),
      Math.round(tileSize[1] * pixelRatio)
    ];
  };
  VectorTile2.prototype.updateCacheSize = function(tileCount, projection) {
    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);
    this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(projection).highWaterMark;
  };
  return VectorTile2;
}(UrlTile_default);
var VectorTile_default2 = VectorTile;
function defaultLoadFunction(tile, url) {
  tile.setLoader(function(extent, resolution, projection) {
    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
  });
}

// node_modules/ol/net.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function jsonp(url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement("script");
  var key = "olc_" + getUid(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.indexOf("?") == -1 ? "?" : "&") + (opt_callbackParam || "callback") + "=" + key;
  var timer = setTimeout(function() {
    cleanup();
    if (opt_errback) {
      opt_errback();
    }
  }, 1e4);
  window[key] = function(data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };
  document.getElementsByTagName("head")[0].appendChild(script);
}
var ResponseError = function(_super) {
  __extends5(ResponseError2, _super);
  function ResponseError2(response) {
    var _this = this;
    var message = "Unexpected response status: " + response.status;
    _this = _super.call(this, message) || this;
    _this.name = "ResponseError";
    _this.response = response;
    return _this;
  }
  return ResponseError2;
}(Error);
var ClientError = function(_super) {
  __extends5(ClientError2, _super);
  function ClientError2(client) {
    var _this = _super.call(this, "Failed to issue request") || this;
    _this.name = "ClientError";
    _this.client = client;
    return _this;
  }
  return ClientError2;
}(Error);

// node_modules/ol/source/TileJSON.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileJSON = function(_super) {
  __extends6(TileJSON2, _super);
  function TileJSON2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: get("EPSG:3857"),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: State_default.LOADING,
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.tileJSON_ = null;
    _this.tileSize_ = options.tileSize;
    if (options.url) {
      if (options.jsonp) {
        jsonp(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener("load", _this.onXHRLoad_.bind(_this));
        client.addEventListener("error", _this.onXHRError_.bind(_this));
        client.open("GET", options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      assert(false, 51);
    }
    return _this;
  }
  TileJSON2.prototype.onXHRLoad_ = function(event) {
    var client = event.target;
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;
      try {
        response = JSON.parse(client.responseText);
      } catch (err) {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };
  TileJSON2.prototype.onXHRError_ = function(event) {
    this.handleTileJSONError();
  };
  TileJSON2.prototype.getTileJSON = function() {
    return this.tileJSON_;
  };
  TileJSON2.prototype.handleTileJSONResponse = function(tileJSON) {
    var epsg4326Projection = get("EPSG:4326");
    var sourceProjection = this.getProjection();
    var extent;
    if (tileJSON["bounds"] !== void 0) {
      var transform = getTransformFromProjections(epsg4326Projection, sourceProjection);
      extent = applyTransform(tileJSON["bounds"], transform);
    }
    var gridExtent = extentFromProjection(sourceProjection);
    var minZoom = tileJSON["minzoom"] || 0;
    var maxZoom = tileJSON["maxzoom"] || 22;
    var tileGrid = createXYZ({
      extent: gridExtent,
      maxZoom,
      minZoom,
      tileSize: this.tileSize_
    });
    this.tileGrid = tileGrid;
    this.tileUrlFunction = createFromTemplates(tileJSON["tiles"], tileGrid);
    if (tileJSON["attribution"] !== void 0 && !this.getAttributions()) {
      var attributionExtent_1 = extent !== void 0 ? extent : gridExtent;
      this.setAttributions(function(frameState) {
        if (intersects(attributionExtent_1, frameState.extent)) {
          return [tileJSON["attribution"]];
        }
        return null;
      });
    }
    this.tileJSON_ = tileJSON;
    this.setState(State_default.READY);
  };
  TileJSON2.prototype.handleTileJSONError = function() {
    this.setState(State_default.ERROR);
  };
  return TileJSON2;
}(TileImage_default);
var TileJSON_default = TileJSON;

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BaseTileLayer = function(_super) {
  __extends7(BaseTileLayer2, _super);
  function BaseTileLayer2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var baseOptions = assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.setPreload(options.preload !== void 0 ? options.preload : 0);
    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true);
    return _this;
  }
  BaseTileLayer2.prototype.getPreload = function() {
    return this.get(TileProperty_default.PRELOAD);
  };
  BaseTileLayer2.prototype.setPreload = function(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  };
  BaseTileLayer2.prototype.getUseInterimTilesOnError = function() {
    return this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR);
  };
  BaseTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };
  return BaseTileLayer2;
}(Layer_default);
var BaseTile_default = BaseTileLayer;

// node_modules/ol/renderer/canvas/TileLayer.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CanvasTileLayerRenderer = function(_super) {
  __extends8(CanvasTileLayerRenderer2, _super);
  function CanvasTileLayerRenderer2(tileLayer) {
    var _this = _super.call(this, tileLayer) || this;
    _this.extentChanged = true;
    _this.renderedExtent_ = null;
    _this.renderedPixelRatio;
    _this.renderedProjection = null;
    _this.renderedRevision;
    _this.renderedTiles = [];
    _this.newTiles_ = false;
    _this.tmpExtent = createEmpty();
    _this.tmpTileRange_ = new TileRange_default(0, 0, 0, 0);
    return _this;
  }
  CanvasTileLayerRenderer2.prototype.isDrawableTile = function(tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  };
  CanvasTileLayerRenderer2.prototype.getTile = function(z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile.getState() == TileState_default.ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        tile.setState(TileState_default.LOADED);
      } else if (tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }
    return tile;
  };
  CanvasTileLayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
    }
    return false;
  };
  CanvasTileLayerRenderer2.prototype.prepareFrame = function(frameState) {
    return !!this.getLayer().getSource();
  };
  CanvasTileLayerRenderer2.prototype.renderFrame = function(frameState, target) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;
    var rotation = viewState.rotation;
    var pixelRatio = frameState.pixelRatio;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var extent = frameState.extent;
    var layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      extent = getIntersection(extent, fromUserExtent(layerState.extent, projection));
    }
    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    var width = Math.round(frameState.size[0] * tilePixelRatio);
    var height = Math.round(frameState.size[1] * tilePixelRatio);
    if (rotation) {
      var size = Math.round(Math.sqrt(width * width + height * height));
      width = size;
      height = size;
    }
    var dx = tileResolution * width / 2 / tilePixelRatio;
    var dy = tileResolution * height / 2 / tilePixelRatio;
    var canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var tile = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile)) {
          var uid = getUid(this);
          if (tile.getState() == TileState_default.LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);
            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }
          if (tile.getAlpha(uid, frameState.time) === 1) {
            continue;
          }
        }
        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
        }
      }
    }
    var canvasScale = tileResolution / viewResolution;
    compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
    var canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    assign(context, tileSource.getContextOptions());
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(numberSafeCompareFunction);
    var clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (var i = zs.length - 1; i >= 0; --i) {
      var currentZ = zs[i];
      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      var currentResolution = tileGrid.getResolution(currentZ);
      var currentScale = currentResolution / tileResolution;
      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
      var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      var origin_1 = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      var tilesToDraw = tilesToDrawByZ[currentZ];
      for (var tileCoordKey in tilesToDraw) {
        var tile = tilesToDraw[tileCoordKey];
        var tileCoord = tile.tileCoord;
        var xIndex = originTileCoord[1] - tileCoord[1];
        var nextX = Math.round(origin_1[0] - (xIndex - 1) * dx_1);
        var yIndex = originTileCoord[2] - tileCoord[2];
        var nextY = Math.round(origin_1[1] - (yIndex - 1) * dy_1);
        var x = Math.round(origin_1[0] - xIndex * dx_1);
        var y = Math.round(origin_1[1] - yIndex * dy_1);
        var w = nextX - x;
        var h = nextY - y;
        var transition = z === currentZ;
        var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;
        if (!inTransition) {
          if (clips) {
            context.save();
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
              if (z !== currentZ && currentZ < clipZs[i_1]) {
                var clip = clips[i_1];
                context.beginPath();
                context.moveTo(currentClip[0], currentClip[1]);
                context.lineTo(currentClip[2], currentClip[3]);
                context.lineTo(currentClip[4], currentClip[5]);
                context.lineTo(currentClip[6], currentClip[7]);
                context.moveTo(clip[6], clip[7]);
                context.lineTo(clip[4], clip[5]);
                context.lineTo(clip[2], clip[3]);
                context.lineTo(clip[0], clip[1]);
                context.clip();
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition);
        if (clips && !inTransition) {
          context.restore();
          this.renderedTiles.unshift(tile);
        } else {
          this.renderedTiles.push(tile);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    var opacity = cssOpacity(layerState.opacity);
    var container = this.container;
    if (opacity !== container.style.opacity) {
      container.style.opacity = opacity;
    }
    return this.container;
  };
  CanvasTileLayerRenderer2.prototype.drawTileImage = function(tile, frameState, x, y, w, h, gutter, transition) {
    var image = this.getTileImage(tile);
    if (!image) {
      return;
    }
    var uid = getUid(this);
    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };
  CanvasTileLayerRenderer2.prototype.getImage = function() {
    var context = this.context;
    return context ? context.canvas : null;
  };
  CanvasTileLayerRenderer2.prototype.getTileImage = function(tile) {
    return tile.getImage();
  };
  CanvasTileLayerRenderer2.prototype.scheduleExpireCache = function(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      var postRenderFunction = function(tileSource2, map, frameState2) {
        var tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(frameState2.viewState.projection, frameState2.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(postRenderFunction);
    }
  };
  CanvasTileLayerRenderer2.prototype.updateUsedTiles = function(usedTiles, tileSource, tile) {
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  };
  CanvasTileLayerRenderer2.prototype.manageTilePyramid = function(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
    var tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tileCount = 0;
    var tile, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile.getState() == TileState_default.IDLE) {
              wantedTiles[tile.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([
                  tile,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (opt_tileCallback !== void 0) {
              opt_tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  };
  return CanvasTileLayerRenderer2;
}(Layer_default2);
CanvasTileLayerRenderer.prototype.getLayer;
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/Tile.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileLayer = function(_super) {
  __extends9(TileLayer2, _super);
  function TileLayer2(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  TileLayer2.prototype.createRenderer = function() {
    return new TileLayer_default(this);
  };
  return TileLayer2;
}(BaseTile_default);
var Tile_default = TileLayer;

export {
  ImageLayer_default,
  Image_default,
  TileLayer_default,
  TileProperty_default,
  VectorTile_default2 as VectorTile_default,
  jsonp,
  TileJSON_default,
  BaseTile_default,
  Tile_default
};
//# sourceMappingURL=chunk-7U2W7G76.js.map
