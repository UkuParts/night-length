import {
  __commonJS,
  __esm,
  __export,
  __spreadProps,
  __spreadValues
} from "./chunk-B7LZDY4N.js";

// node_modules/ky/index.js
var globals, getGlobal, globalProperties, isObject, supportsAbortController, supportsStreams, supportsFormData, mergeHeaders, deepMerge, requestMethods, responseTypes, retryMethods, retryStatusCodes, retryAfterStatusCodes, stop, HTTPError, TimeoutError, delay, timeout, normalizeRequestMethod, defaultRetryOptions, normalizeRetryOptions, maxSafeTimeout, Ky, validateAndMerge, createInstance, ky_default;
var init_ky = __esm({
  "node_modules/ky/index.js"() {
    globals = {};
    getGlobal = (property) => {
      if (typeof self !== "undefined" && self && property in self) {
        return self;
      }
      if (typeof window !== "undefined" && window && property in window) {
        return window;
      }
      if (typeof global !== "undefined" && global && property in global) {
        return global;
      }
      if (typeof globalThis !== "undefined" && globalThis) {
        return globalThis;
      }
    };
    globalProperties = [
      "Headers",
      "Request",
      "Response",
      "ReadableStream",
      "fetch",
      "AbortController",
      "FormData"
    ];
    for (const property of globalProperties) {
      Object.defineProperty(globals, property, {
        get() {
          const globalObject = getGlobal(property);
          const value = globalObject && globalObject[property];
          return typeof value === "function" ? value.bind(globalObject) : value;
        }
      });
    }
    isObject = (value) => value !== null && typeof value === "object";
    supportsAbortController = typeof globals.AbortController === "function";
    supportsStreams = typeof globals.ReadableStream === "function";
    supportsFormData = typeof globals.FormData === "function";
    mergeHeaders = (source1, source2) => {
      const result = new globals.Headers(source1 || {});
      const isHeadersInstance = source2 instanceof globals.Headers;
      const source = new globals.Headers(source2 || {});
      for (const [key, value] of source) {
        if (isHeadersInstance && value === "undefined" || value === void 0) {
          result.delete(key);
        } else {
          result.set(key, value);
        }
      }
      return result;
    };
    deepMerge = (...sources) => {
      let returnValue = {};
      let headers = {};
      for (const source of sources) {
        if (Array.isArray(source)) {
          if (!Array.isArray(returnValue)) {
            returnValue = [];
          }
          returnValue = [...returnValue, ...source];
        } else if (isObject(source)) {
          for (let [key, value] of Object.entries(source)) {
            if (isObject(value) && key in returnValue) {
              value = deepMerge(returnValue[key], value);
            }
            returnValue = __spreadProps(__spreadValues({}, returnValue), { [key]: value });
          }
          if (isObject(source.headers)) {
            headers = mergeHeaders(headers, source.headers);
          }
        }
        returnValue.headers = headers;
      }
      return returnValue;
    };
    requestMethods = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    responseTypes = {
      json: "application/json",
      text: "text/*",
      formData: "multipart/form-data",
      arrayBuffer: "*/*",
      blob: "*/*"
    };
    retryMethods = [
      "get",
      "put",
      "head",
      "delete",
      "options",
      "trace"
    ];
    retryStatusCodes = [
      408,
      413,
      429,
      500,
      502,
      503,
      504
    ];
    retryAfterStatusCodes = [
      413,
      429,
      503
    ];
    stop = Symbol("stop");
    HTTPError = class extends Error {
      constructor(response) {
        super(response.statusText || String(response.status === 0 || response.status ? response.status : "Unknown response error"));
        this.name = "HTTPError";
        this.response = response;
      }
    };
    TimeoutError = class extends Error {
      constructor(request) {
        super("Request timed out");
        this.name = "TimeoutError";
        this.request = request;
      }
    };
    delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    timeout = (request, abortController, options) => new Promise((resolve, reject) => {
      const timeoutID = setTimeout(() => {
        if (abortController) {
          abortController.abort();
        }
        reject(new TimeoutError(request));
      }, options.timeout);
      options.fetch(request).then(resolve).catch(reject).then(() => {
        clearTimeout(timeoutID);
      });
    });
    normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
    defaultRetryOptions = {
      limit: 2,
      methods: retryMethods,
      statusCodes: retryStatusCodes,
      afterStatusCodes: retryAfterStatusCodes
    };
    normalizeRetryOptions = (retry = {}) => {
      if (typeof retry === "number") {
        return __spreadProps(__spreadValues({}, defaultRetryOptions), {
          limit: retry
        });
      }
      if (retry.methods && !Array.isArray(retry.methods)) {
        throw new Error("retry.methods must be an array");
      }
      if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
        throw new Error("retry.statusCodes must be an array");
      }
      return __spreadProps(__spreadValues(__spreadValues({}, defaultRetryOptions), retry), {
        afterStatusCodes: retryAfterStatusCodes
      });
    };
    maxSafeTimeout = 2147483647;
    Ky = class {
      constructor(input, options = {}) {
        this._retryCount = 0;
        this._input = input;
        this._options = __spreadProps(__spreadValues({
          credentials: this._input.credentials || "same-origin"
        }, options), {
          headers: mergeHeaders(this._input.headers, options.headers),
          hooks: deepMerge({
            beforeRequest: [],
            beforeRetry: [],
            afterResponse: []
          }, options.hooks),
          method: normalizeRequestMethod(options.method || this._input.method),
          prefixUrl: String(options.prefixUrl || ""),
          retry: normalizeRetryOptions(options.retry),
          throwHttpErrors: options.throwHttpErrors !== false,
          timeout: typeof options.timeout === "undefined" ? 1e4 : options.timeout,
          fetch: options.fetch || globals.fetch
        });
        if (typeof this._input !== "string" && !(this._input instanceof URL || this._input instanceof globals.Request)) {
          throw new TypeError("`input` must be a string, URL, or Request");
        }
        if (this._options.prefixUrl && typeof this._input === "string") {
          if (this._input.startsWith("/")) {
            throw new Error("`input` must not begin with a slash when using `prefixUrl`");
          }
          if (!this._options.prefixUrl.endsWith("/")) {
            this._options.prefixUrl += "/";
          }
          this._input = this._options.prefixUrl + this._input;
        }
        if (supportsAbortController) {
          this.abortController = new globals.AbortController();
          if (this._options.signal) {
            this._options.signal.addEventListener("abort", () => {
              this.abortController.abort();
            });
          }
          this._options.signal = this.abortController.signal;
        }
        this.request = new globals.Request(this._input, this._options);
        if (this._options.searchParams) {
          const searchParams = "?" + new URLSearchParams(this._options.searchParams).toString();
          const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
          if ((supportsFormData && this._options.body instanceof globals.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"])) {
            this.request.headers.delete("content-type");
          }
          this.request = new globals.Request(new globals.Request(url, this.request), this._options);
        }
        if (this._options.json !== void 0) {
          this._options.body = JSON.stringify(this._options.json);
          this.request.headers.set("content-type", "application/json");
          this.request = new globals.Request(this.request, { body: this._options.body });
        }
        const fn = async () => {
          if (this._options.timeout > maxSafeTimeout) {
            throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
          }
          await delay(1);
          let response = await this._fetch();
          for (const hook of this._options.hooks.afterResponse) {
            const modifiedResponse = await hook(this.request, this._options, this._decorateResponse(response.clone()));
            if (modifiedResponse instanceof globals.Response) {
              response = modifiedResponse;
            }
          }
          this._decorateResponse(response);
          if (!response.ok && this._options.throwHttpErrors) {
            throw new HTTPError(response);
          }
          if (this._options.onDownloadProgress) {
            if (typeof this._options.onDownloadProgress !== "function") {
              throw new TypeError("The `onDownloadProgress` option must be a function");
            }
            if (!supportsStreams) {
              throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
            }
            return this._stream(response.clone(), this._options.onDownloadProgress);
          }
          return response;
        };
        const isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());
        const result = isRetriableMethod ? this._retry(fn) : fn();
        for (const [type, mimeType] of Object.entries(responseTypes)) {
          result[type] = async () => {
            this.request.headers.set("accept", this.request.headers.get("accept") || mimeType);
            const response = (await result).clone();
            if (type === "json") {
              if (response.status === 204) {
                return "";
              }
              if (options.parseJson) {
                return options.parseJson(await response.text());
              }
            }
            return response[type]();
          };
        }
        return result;
      }
      _calculateRetryDelay(error) {
        this._retryCount++;
        if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
          if (error instanceof HTTPError) {
            if (!this._options.retry.statusCodes.includes(error.response.status)) {
              return 0;
            }
            const retryAfter = error.response.headers.get("Retry-After");
            if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
              let after = Number(retryAfter);
              if (Number.isNaN(after)) {
                after = Date.parse(retryAfter) - Date.now();
              } else {
                after *= 1e3;
              }
              if (typeof this._options.retry.maxRetryAfter !== "undefined" && after > this._options.retry.maxRetryAfter) {
                return 0;
              }
              return after;
            }
            if (error.response.status === 413) {
              return 0;
            }
          }
          const BACKOFF_FACTOR = 0.3;
          return BACKOFF_FACTOR * 2 ** (this._retryCount - 1) * 1e3;
        }
        return 0;
      }
      _decorateResponse(response) {
        if (this._options.parseJson) {
          response.json = async () => {
            return this._options.parseJson(await response.text());
          };
        }
        return response;
      }
      async _retry(fn) {
        try {
          return await fn();
        } catch (error) {
          const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
          if (ms !== 0 && this._retryCount > 0) {
            await delay(ms);
            for (const hook of this._options.hooks.beforeRetry) {
              const hookResult = await hook({
                request: this.request,
                options: this._options,
                error,
                retryCount: this._retryCount
              });
              if (hookResult === stop) {
                return;
              }
            }
            return this._retry(fn);
          }
          if (this._options.throwHttpErrors) {
            throw error;
          }
        }
      }
      async _fetch() {
        for (const hook of this._options.hooks.beforeRequest) {
          const result = await hook(this.request, this._options);
          if (result instanceof Request) {
            this.request = result;
            break;
          }
          if (result instanceof Response) {
            return result;
          }
        }
        if (this._options.timeout === false) {
          return this._options.fetch(this.request.clone());
        }
        return timeout(this.request.clone(), this.abortController, this._options);
      }
      _stream(response, onDownloadProgress) {
        const totalBytes = Number(response.headers.get("content-length")) || 0;
        let transferredBytes = 0;
        return new globals.Response(new globals.ReadableStream({
          start(controller) {
            const reader = response.body.getReader();
            if (onDownloadProgress) {
              onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
            }
            async function read() {
              const { done, value } = await reader.read();
              if (done) {
                controller.close();
                return;
              }
              if (onDownloadProgress) {
                transferredBytes += value.byteLength;
                const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
                onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
              }
              controller.enqueue(value);
              read();
            }
            read();
          }
        }));
      }
    };
    validateAndMerge = (...sources) => {
      for (const source of sources) {
        if ((!isObject(source) || Array.isArray(source)) && typeof source !== "undefined") {
          throw new TypeError("The `options` argument must be an object");
        }
      }
      return deepMerge({}, ...sources);
    };
    createInstance = (defaults) => {
      const ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));
      for (const method of requestMethods) {
        ky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, { method }));
      }
      ky.HTTPError = HTTPError;
      ky.TimeoutError = TimeoutError;
      ky.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
      ky.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
      ky.stop = stop;
      return ky;
    };
    ky_default = createInstance();
  }
});

// node_modules/ky-universal/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => ky_default
});
var init_browser = __esm({
  "node_modules/ky-universal/browser.js"() {
    init_ky();
  }
});

// node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/map-obj/index.js"(exports, module) {
    "use strict";
    var isObject2 = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject = (object, mapper, options, isSeen = new WeakMap()) => {
      options = __spreadValues({
        deep: false,
        target: {}
      }, options);
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module.exports = (object, mapper, options) => {
      if (!isObject2(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject(object, mapper, options);
    };
    module.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports, module) {
    "use strict";
    var preserveCamelCase = (string) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string;
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module.exports = camelCase;
    module.exports.default = camelCase;
  }
});

// node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.cache = new Map();
        this.oldCache = new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          this.oldCache = this.cache;
          this.cache = new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return this._size + oldCacheSize;
      }
    };
    module.exports = QuickLRU;
  }
});

// node_modules/camelcase-keys/index.js
var require_camelcase_keys = __commonJS({
  "node_modules/camelcase-keys/index.js"(exports, module) {
    "use strict";
    var mapObj = require_map_obj();
    var camelCase = require_camelcase();
    var QuickLru = require_quick_lru();
    var has = (array, key) => array.some((x) => {
      if (typeof x === "string") {
        return x === key;
      }
      x.lastIndex = 0;
      return x.test(key);
    });
    var cache = new QuickLru({ maxSize: 1e5 });
    var isObject2 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var camelCaseConvert = (input, options) => {
      if (!isObject2(input)) {
        return input;
      }
      options = __spreadValues({
        deep: false,
        pascalCase: false
      }, options);
      const { exclude, pascalCase, stopPaths, deep } = options;
      const stopPathsSet = new Set(stopPaths);
      const makeMapper = (parentPath) => (key, value) => {
        if (deep && isObject2(value)) {
          const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
          if (!stopPathsSet.has(path)) {
            value = mapObj(value, makeMapper(path));
          }
        }
        if (!(exclude && has(exclude, key))) {
          const cacheKey = pascalCase ? `${key}_` : key;
          if (cache.has(cacheKey)) {
            key = cache.get(cacheKey);
          } else {
            const ret = camelCase(key, { pascalCase });
            if (key.length < 100) {
              cache.set(cacheKey, ret);
            }
            key = ret;
          }
        }
        return [key, value];
      };
      return mapObj(input, makeMapper(void 0));
    };
    module.exports = (input, options) => {
      if (Array.isArray(input)) {
        return Object.keys(input).map((key) => camelCaseConvert(input[key], options));
      }
      return camelCaseConvert(input, options);
    };
  }
});

// node_modules/sunrise-sunset-api/build/mocks.js
var require_mocks = __commonJS({
  "node_modules/sunrise-sunset-api/build/mocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MOCK_UNFORMATTED_RESPONSE = exports.MOCK_RAW_UNFORMATTED_RESPONSE = exports.MOCK_FORMATTED_RESPONSE = exports.MOCK_RAW_FORMATTED_RESPONSE = void 0;
    exports.MOCK_RAW_FORMATTED_RESPONSE = {
      results: {
        sunrise: "7:27:02 AM",
        sunset: "5:05:55 PM",
        solar_noon: "12:16:28 PM",
        day_length: "9:38:53",
        civil_twilight_begin: "6:58:14 AM",
        civil_twilight_end: "5:34:43 PM",
        nautical_twilight_begin: "6:25:47 AM",
        nautical_twilight_end: "6:07:10 PM",
        astronomical_twilight_begin: "5:54:14 AM",
        astronomical_twilight_end: "6:38:43 PM"
      },
      status: "OK"
    };
    exports.MOCK_FORMATTED_RESPONSE = {
      sunrise: "7:27:02 AM",
      sunset: "5:05:55 PM",
      solarNoon: "12:16:28 PM",
      dayLength: "9:38:53",
      civilTwilightBegin: "6:58:14 AM",
      civilTwilightEnd: "5:34:43 PM",
      nauticalTwilightBegin: "6:25:47 AM",
      nauticalTwilightEnd: "6:07:10 PM",
      astronomicalTwilightBegin: "5:54:14 AM",
      astronomicalTwilightEnd: "6:38:43 PM"
    };
    exports.MOCK_RAW_UNFORMATTED_RESPONSE = {
      results: {
        sunrise: "2015-05-21T05:05:35+00:00",
        sunset: "2015-05-21T19:22:59+00:00",
        solar_noon: "2015-05-21T12:14:17+00:00",
        day_length: 51444,
        civil_twilight_begin: "2015-05-21T04:36:17+00:00",
        civil_twilight_end: "2015-05-21T19:52:17+00:00",
        nautical_twilight_begin: "2015-05-21T04:00:13+00:00",
        nautical_twilight_end: "2015-05-21T20:28:21+00:00",
        astronomical_twilight_begin: "2015-05-21T03:20:49+00:00",
        astronomical_twilight_end: "2015-05-21T21:07:45+00:00"
      },
      status: "OK"
    };
    exports.MOCK_UNFORMATTED_RESPONSE = {
      sunrise: "2015-05-21T05:05:35+00:00",
      sunset: "2015-05-21T19:22:59+00:00",
      solarNoon: "2015-05-21T12:14:17+00:00",
      dayLength: 51444,
      civilTwilightBegin: "2015-05-21T04:36:17+00:00",
      civilTwilightEnd: "2015-05-21T19:52:17+00:00",
      nauticalTwilightBegin: "2015-05-21T04:00:13+00:00",
      nauticalTwilightEnd: "2015-05-21T20:28:21+00:00",
      astronomicalTwilightBegin: "2015-05-21T03:20:49+00:00",
      astronomicalTwilightEnd: "2015-05-21T21:07:45+00:00"
    };
  }
});

// node_modules/sunrise-sunset-api/build/index.js
var require_build = __commonJS({
  "node_modules/sunrise-sunset-api/build/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSunriseSunsetInfo = exports.MOCK_UNFORMATTED_RESPONSE = exports.MOCK_FORMATTED_RESPONSE = void 0;
    var ky_universal_1 = __importDefault((init_browser(), browser_exports));
    var camelcase_keys_1 = __importDefault(require_camelcase_keys());
    var mocks_1 = require_mocks();
    Object.defineProperty(exports, "MOCK_FORMATTED_RESPONSE", { enumerable: true, get: function() {
      return mocks_1.MOCK_FORMATTED_RESPONSE;
    } });
    Object.defineProperty(exports, "MOCK_UNFORMATTED_RESPONSE", { enumerable: true, get: function() {
      return mocks_1.MOCK_UNFORMATTED_RESPONSE;
    } });
    function getSunriseSunsetInfo(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!options.latitude) {
          throw new Error("Latitude is a required parameter");
        }
        if (!options.longitude) {
          throw new Error("Longitude is a required parameter");
        }
        if (typeof options.latitude !== "number" || !isFinite(options.latitude) || Math.abs(options.latitude) > 90) {
          throw new Error("Latitude must be a number between -90 and 90 (inclusive)");
        }
        if (typeof options.longitude !== "number" || !isFinite(options.longitude) || Math.abs(options.longitude) > 180) {
          throw new Error("Longitude must be a number between -180 and 180 (inclusive)");
        }
        if (typeof options.date !== "undefined" && options.date !== null && typeof options.date !== "string") {
          throw new Error("Invalid date");
        }
        if (options.useMocks) {
          if (typeof options.formatted === "undefined" || options.formatted) {
            return mocks_1.MOCK_FORMATTED_RESPONSE;
          } else {
            return mocks_1.MOCK_UNFORMATTED_RESPONSE;
          }
        }
        const response = yield ky_universal_1.default(options.apiUrl || "https://api.sunrise-sunset.org/json", Object.assign({ method: "get", searchParams: Object.assign(Object.assign({ lat: options.latitude, lng: options.longitude }, typeof options.date === "string" && { date: options.date }), typeof options.formatted === "boolean" && {
          formatted: options.formatted ? 1 : 0
        }) }, options.kyOptions));
        const body = yield response.json();
        return camelcase_keys_1.default(body.results);
      });
    }
    exports.getSunriseSunsetInfo = getSunriseSunsetInfo;
  }
});

// dep:sunrise-sunset-api
var sunrise_sunset_api_default = require_build();
export {
  sunrise_sunset_api_default as default
};
/*! MIT License © Sindre Sorhus */
//# sourceMappingURL=sunrise-sunset-api.js.map
